---
id: Introduction
title: 绪论
tags: 
  - 数据结构
---

## 基本概念和术语

### 数据（data)

所有能输入到计算机中去的描述客观事物的符号。

### 数据元素（data element）【“结点”，“元素”，“记录”】

数据的基本单位。  
常用于完整地描述一个对象。

### 数据项（data item）【“域”】

组成数据元素的、有独立含义的、不可分割的最小单位。

:::tip 
数据、数据元素、数据项三者之间的关系：

**数据 > 数据元素   >  数据项**

例：学生表 >  个人记录 >  学号、姓名……

:::

:::info 理解数据元素
- 通常情况下，数据元素具有相同`个数`和`类型`的数据项
- 一般来说，能**独立、完整**地描述问题世界的一切实体都是数据元素
:::

### 数据对象(Data Object)

性质相同的数据元素的集合，是数据的一个子集。

- 不论数据元素集合是什么样的集合，只要集合内元素的性质均相同，都可以称之为一个数据对象。

### 数据结构（Data Structure）

相互之间存在一种或多种特定关系的数据元素的集合。

- 换言之，数据结构就是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。

## 数据结构的层次

数据结构包括`逻辑结构`和`存储结构`两个层次。

### 逻辑结构

数据元素间抽象化的相互关系，从逻辑关系上描述数据，与数据的存储无关，独立于计算机。  
它是可以看作从具体问题中抽象出来的数学模型。

数据的逻辑结构的两个要素：
1. 数据元素
2. 关系

#### 按照划分方法一可划分为：
1. 线性结构
- 有且仅有一个开始和一个终端结点,并且所有结点都最多只有一个直接前趋和一个后继。
- 例如：线性表、栈、队列、串
2. 非线性结构
- 一个结点可能有多个直接前趋和直接后继
- 例如：树、图

#### 按照划分方法二可划分为（复杂程度依次递进）：
1. 集合结构
- 数据元素间除“同属于一个集合”外，无其它关系
2. 线性结构
- 一个对一个，如线性表、栈、队列
3. 树结构
- 一个对多个，如树
4. 图结构或网状结构
- 多个对多个，如图
:::info
其中，集合结构、树结构、图结构或网状结构都属于非线性结构。  
以上逻辑结构可以用下面这个层次图描述：
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/10814b7b701ceb4057fa6a26bc4ccd1.jpg)
:::

### 存储结构(物理结构)

数据元素及其关系在计算机存储器中的存储方式。

数据元素在计算机中有两种基本的存储结构，分别是`顺序存储结构`和`链式存储结构`。

#### 顺序存储结构

借助元素在存储器中的相对位置来表示数据元素间的逻辑关系。  
通常借助程序设计语言的数组类型来描述。  
顺序存储结构要求所有的元素依次存放在一片连续的存储空间中。


#### 链式存储结构

借助指示元素存储地址的指针表示数据元素间的逻辑关系。  
通常借助程序设计语言的指针类型来描述。  

:::info 数据的运算
逻辑结构和存储结构都相同, 但运算不同, 则数据结构不同. 例如, 栈与队列。

运算的实现依赖于数据的存储结构。
:::

:::info 逻辑结构和存储结构的关系
- 逻辑结构是用户视图，面向问题
    - 数据本身的构成方式

- 存储结构是实现视图，面向计算机
    - 数据在内存中的存储表示

一种数据的逻辑结构可以采用多种存储结构来实现，采用不同的存储结构，其数据处理的效率往往是不同的。
（即：数据的逻辑结构唯一，但存储结构不唯一。）
:::

:::tip
1. 逻辑结构与数据元素本身的内容和形式**无关**。
2. 基于某种逻辑结构之上的基本操作，其实现是**不唯一**的。
3. 理论上讲，存储结构与程序设计语言**有关**。
:::

## 数据类型和抽象数据类型

### 数据类型

数据类型是一组性质相同的值的集合, 以及定义于这个集合上的一组运算的总称。

也可以理解为：在一种程序设计语言中，变量所具有的数据种类。  
例如：
- FORTRAN语言：
    - 整型、实型、复数型
- C语言：
    - 基本数据类型：char、int、float、double、void
    - 构造数据类型：数组、结构体、共用体、文件

### 抽象数据类型(ADT: Abstract  Data Type)

一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。具体包括三个部分：数据对象、数据对象上的关系的集合以及对数据对象的基本操作的集合。

抽象数据类型可以用以下的三元组来表示：
```
ADT = （D，S，P）
//D:数据对象
//S:D上的关系集
//P:D上的操作集
```

```md title="ADT常用定义格式"
ADT抽象数据类型名{ 
        数据对象：<数据对象的定义>
        数据关系：<数据关系的定义> 
        基本操作 ：<基本操作的定义> 
    } ADT抽象数据类型名
```

### 抽象数据类型的表示与实现

抽象数据类型可以通过固有的数据类型（如整型、实型、字符型等）来表示和实现。

#### (1) 预定义常量及类型

```
//函数结果状态代码
 #define OK 1 
 #define ERROR 0 
 #define OVERFLOW -2 

 // Status是函数返回值类型，其值是函数结果状态代码。 
      typedef  int  Status; 
```

#### (2)数据结构的表示（存储结构）用类型定义（typedef）描述

数据元素被约定为ElemType 类型，用户需要根据具体情况，自行定义该数据类型。

#### （3）算法描述为以下的函数形式：

```
函数类型 函数名（函数参数表）
{
   语句序列；
}
```

#### （4）内存的动态分配与释放

```md title="使用new和delete动态分配和释放内存空间"
分配空间　指针变量=new数据类型;
释放空间　delete指针变量;
```

#### （5）赋值语句

```
简单赋值： 变量名 = 表达式 ；
串联赋值： 变量名1 = 变量名2 = ... = 变量名n = 表达式 ；
成组赋值：（变量名1，...，变量名n） = （表达式1，...，表达式n）；
结构赋值： 结构名1 = 结构名2 ；
          结构名 = （值1，值2，...，值n）；
条件赋值： 变量名 = 条件表达式 ？表达式T ：表达式F ；
交换赋值： 变量名1 <--> 变量名2；
```
#### （6）选择语句

```
1. if {...}
2. if {...}
   else {...}
3. switch {
    case1: ...
    case2: ...
    ...
    default: ...
}
```
#### （7）循环语句

```
1、for语句
2、while语句
3、do-while语句
```
#### （8）使用的结束语句形式有：
- 函数结束语句  return 
- 循环结束语句  break;
- 异常结束语句  exit（异常代码）；

#### （9）输入输出语句形式有：

```
输入语句   cin>>...     (相当于scanf( ))
输出语句   cout <<...   (相当于printf( ))
```

#### （10）扩展函数有：

```
求最大值  max
求最小值  min
```

## 算法和算法分析

### 算法

#### 定义

为了解决某类问题而规定的一个有限长的操作序列。

#### 特性

1. 输入：有**0个或多个**输入
2. 输出：有**1个或多个**输出
3. 有穷性：算法应在执行**有穷步**后结束
4. 确定性：操作步骤可以通过**已经实现的基本操作**执行**有限次**来实现
5. 可行性：每步定义都是确切、**无歧义**的

#### 评价算法优劣的基本标准

1. 正确性：在合理的数据输入下，能够在有限的运行时间内得到正确的结果
2. 可读性：便于人们理解和相互交流
3. 健壮性：当输入的数据非法时，能够进行正确反应或进行相应的处理
4. 高效性：时间高效和空间高效

### 衡量算法效率

- 算法效率：用依据该算法编制的程序在计算机上执行所消耗的时间来度量

衡量算法效率的方法有两类：**事后统计法**和**事前分析估算法**

#### 事后统计法

利用计算机内的计时功能，不同算法的程序可以用一组或多组相同的统计数据区分。

缺点：
- 必须先运行依据算法编制的程序
- 所得时间统计量依赖于硬件、软件等环境因素，掩盖算法本身的优劣     

#### 事前分析估算法

考虑到事后统计法的不足之处，我们常用事前分析估算法，通过计算**算法的渐进复杂度**来衡量算法的效率。

:::info 
表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称渐近时间复杂度。
:::

## 算法的时间、空间复杂度

### 问题规模和语句频度

#### 问题规模

问题规模是算法求解问题输入量的多少，是问题大小的本质，一般用整数n表示。  
在不考虑计算机的软硬件等环境因素的前提下，问题规模是影响算法时间代价的最主要因素。

问题规模n对于不同的问题含义不同：
- 排序：参与排序的记录数
- 矩阵：矩阵的阶数
- 多项式：多项式的项数
- 集合：集合中元素的个数
- 树：树的节点个数
- 图：图的顶点数或边数

显然地，n越大算法的执行时间越长。

#### 语句频度

一条语句的重复执行次数称为语句频度（Frequency Count）。

假设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量，该频度之和记作f(n)。

### 时间复杂度

一般地，算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间复杂度记作：
    T(n)=O(f(n))
它表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称渐近时间复杂度，简称时间复杂度。

:::info 数学符号“O”的定义
若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n) = O(f(n))表示存在正的常数C和n<sub>0</sub>，使得当n≥n<sub>0</sub>时都满足0≤T(n)≤Cf(n)。
:::

### 算法的时间复杂度的分析举例

:::info ✨✨分析算法时间复杂度的基本方法✨✨
- 找出**语句频度最大**的那条语句作为**基本语句**
- 计算**基本语句**的频度得到问题规模n的某个函数f(n)
- 取其数量级用符号“O”表示
:::

具体计算数量级时，可以遵循以下定理：

<!-- ```md title="定理1" -->
若f(n)=a<sub>m</sub> n<sup>m</sup> + a<sub>m-1</sub> n<sup>m-1</sup> + ... +a<sub>1</sub> n +a<sub>0</sub> 是一个m次多项式，则T(n)=O(n<sup>m</sup>)。
即：可以忽略所有低次幂项和最高次幂的系数。
<!-- ``` -->

下面只讨论*非递归算法*的时间复杂度：

#### 常量阶

```
{x++;}
{s=0;}
//这俩条语句时间复杂度都是T(n)=O(1)，常量阶
```

实际上。如果算法的执行时间不随问题规模n的增长而增长，算法中语句频度就是某个常数。但即使这个常数再大，算法的时间复杂度都是O(1)。
如下面这个程序：

```
for(i=0;i<1000;i++)
{
    x++;
}
//时间复杂度仍为O(1)
```

#### 线性阶

```
for(i=0;i<1000;i++)
{
    x++;
    s=0;
}
```

上面这个循环内的两条基本语句的频度均为O(n),则这个算法的时间复杂度为T(n)=O(n)。

#### 平方阶

```
(1) x=0;y=0;
(2) for(k=1;k<=n;k++)
(3)     x++;
(4) for(i=1;i<=n;i++)
(5)     for(j=1;j<=n;j++)
(6)         y++;
```

以上程序中频度最大的语句是(6)，其中频度为f(n)=n<sup>2</sup>,则该算法的时间复杂度为T(n)=O(n<sup>2</sup>)。

#### 立方阶

```
(1) x=1;
(2) for(i=1;i<=n;i++)
(3)     for(j=1;j<=i;j++)
(4)         for(k=1;k<=j;k++)
(5)             x++;
```

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/b6769cab3f3a032c3f8c56b498cc84b.jpg)

#### 对数阶

```
for(i=1;i<=n;i=i*2)
{
    x++;
}
```

假设循环体内的基本语句的频度为f(n),则有2<sup>f(n)</sup>≤n，所以f(n)≤log<sub>2</sub>n，所以算法的时间复杂度为T(n)=O(log<sub>2</sub>n)。

:::tip
- 多数情况下，在有若干个循环体时，时间复杂度是由**嵌套最深层语句的频度**决定的
- 有的情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如下图
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220905161720.png)
- 时间复杂度T(n)按数量级递增顺序为： 
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220905162230.png)
:::

### 空间复杂度

算法所需存储空间的度量。记作：`S(n)=O(f(n))`,其中n为问题规模。

算法所需的存储空间分为三部分：
1. 寄存本身所用的指令、常数、变量和输入数据等所需的空间；
2. 算法要占据的空间；
3. 算法要使用的辅助空间。

下图为关于计算空间复杂度的一道例题：
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220905163029.png)