---
id: Representation-and-operation-of-data
title: 数据的表示和运算
tags: 
  - 计算机组成原理
---

数值、文字、符号、语音、图形和图像等统称`信息`，在计算机内部，信息都必须用数字化的形式被存储、加工  和  传送，不同信息要通过`编码`来表示。  
**编码**：是用来将信息从一种形式转变为另一种形式的符号系统，通常选用少量最简单的基本符号和一定的组合规则，以表示出大量复杂多样的信息。  
**信息的数字化编码**：是指用“0”或“1”这种量最少、最简单的二进制数码，并选用一定的组合规则，来表示数据、文字、符号、语音、图形和图像等各种复杂的信息。  
计算机中采用的是**二进制码**。

二进制的优点：
- 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低
- 二进制位1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件
- 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算

## 数据信息的表示方式

### 进位计数制及其相互转换

凡是用数字符号排列，按由低位向高位进位计数的方法叫做**进位计数制**。

**基数**：
- 一种进位计数制允许选用基本数学符号的个数叫`基数`。
- 在基数为J的计数制中，包含J个不同的数字符号，每个数位计满J就向高位进1，即“`逢J进一`”。例如最常用的十进制，其基数为10，每位计满10向高位进1。

**权**：
- 每个数字符号所表示的数值等于该数字符号值乘以一个与数码所在位有关的常数，这个常数叫做“`位权`”，简称“`权`”。位权的大小是以基数为底，数码所在位置的序号为指数的整数次幂。
- 例如十进制数的十分位、个位、十位、百位、千位的权依次是10<sup>-1</sup>、10<sup>0</sup>、10<sup>1</sup>、10<sup>2</sup>、10<sup>3</sup>。

十进制每位的值等于该位的权与该位数码的乘积。  
一个十进制数可以写成**按权展开的多项式和**的形式。  
例如：将十进制数789.23按权展开  
789.23=7×10<sup>2</sup>＋8×10<sup>1</sup> ＋9×10<sup>0</sup>＋2×10<sup>-1</sup>＋3×10<sup>-2</sup>

- 十进制编码特点：
  - 0123456789共10种状态，状态过多
  - 运算组合状态过多
    - 10进制加法组合数=C<sup>2</sup><sub>10</sub> +10 = 55      8进制  36 种     2进制 3  种

- 二进制编码特点：
  - 符号数最少，“0、1” 物理上容易实现
  - 可以表示任何对象(字符，数值，逻辑值)
  - 运算规则简单
    - 0 + 1  = 1 + 0 = 1    		1 + 1 = 0    		 0 + 0 = 0
    - 仅仅三种运算规则，一个异或门即可完成该运算
  - 二进制数和十进制数之间的关系不复杂，易于相互转换。

二进制数据算术运算规则：
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922144732.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922144753.png)

常用进位计数制的表示：

|进位计数制|介绍|用下标表示|用后缀字母表示|C语言中的表示|
|:--:|:--:|:--:|:--:|:--:|
|二进制|共0，1两个数码，基数为2，逢二进一，借一当二|下标2|B(Binary)|无|
|八进制|共0-7八个数码，基数为8，逢八进一，借一当八|小标8|O(Octal)|前缀加0表示八进制数|
|十进制|共0-9十个数码，基数为10，逢十进一，借一当十|下标10(可省略)|D(Decimal)|无|
|十六进制|共0-9，A, B, C, D, E, F十六个数码，基数为16，逢十六进一，借一当十六|下标16|H(Hexadecimal)|前缀加0x表示十六进制数|

#### 进位计数制之间的转换

1. R进制数转十进制数

  - **按权展开法**：将任意一个R进制数转换成十进制数时，求出每一位数字与其位权的乘积之和，即可得到相应的十进制数。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922145706.png)

2. 十进制数转R进制数

  - 整数部分：**除基取余**
    - 用十进制整数除以基数R取余数，直到商为0，得到的余数从下向上排列即可得到R进制整数部分各位的数码。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/dc085c39f388235c3a548916853eb2b.jpg)

  - 小数部分：**乘基取整**
    - 用十进制小数乘以基数R取整数，直到小数部分为0或满足精度要求为止，得到的整数从上向下排列即可得到R进制小数部分各位的数码。

  - 对于既有整数又有小数的十进制数，可以先将整数和小数分别进行转换，然后再合并得到所要结果。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/c70bcb242e75607216b044e0a1c7444.png)

3. 二进制数和八进制数的转换

- 二进制数转换为八进制数方法：
  - 以小数点为界，将二进制数整数部分从右向左3位一组，小数部分从左向右3位一组进行划分，最后一组若不足3位则用0补足，然后写出每组对应的八进制字符，即可得到对应的八进制数。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922151703.png)

- 八进制数转二进制数方法：
  - 以小数点为界，将每位八进制数用相应的3位二进制数代替，然后将其连在一起即可得到对应的二进制数。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922151826.png)

4. 二进制数和十六进制数的转换

- 二进制数转换为十六进制数方法：
  - 以小数点为界，将二进制数整数部分从右向左4位一组，小数部分从左向右4位一组进行划分，最后一组若不足4位则用0补足，然后写出每组对应的十六进制字符，即可得到对应的十六进制数。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922152159.png)

- 十六进制数转换为二进制数方法：
  - 以小数点为界，将每位十六进制数用相应的4位二进制数代替，然后将其连在一起即可得到对应的十六进制数。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922152301.png)

5. 八进制数和十六进制数的转换

- 方法：以二进制为桥梁！
  - 八进制转换为十六进制时，先将八进制数转换为二进制数，再将得到的二进制数转换为十六进制数；
  - 十六进制向八进制转换时，先将十六进制数转换为二进制数，再将得到的二进制数转换为八进制数

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922152430.png)

### 数据的机器数表示

#### 无符号数和带符号数

- 无符号数，整个机器字长的全部二进制位均表示数值位（没有符号位），相当于数的绝对值。
  - 举例：X=01001——表示无符号数9；Y=11001——表示无符号数25
  - 机器字长为n+1位的无符号数的表示范围是0~（2<sup>n+1</sup>-1），最高位是数值位，其权值为2<sup>n</sup>
  - 例如，若机器字长为8位，则数的表示范围是0~255
- 带符号数，即正、负数
  - 最高位是符号位，不再表示数值，`0`为`正`，`1`为`负`
  - 举例：X=01001——表示+9;Y=11001——根据机器数的不同形式表示不同的值

#### 机器数

- 真值    (书写用)
  - 将用`+` `-`表示正负的二进制数称为符号数的真值
- 符号位
  - `+`和`-`在机器里用1位二进制来表示。通常这个符号放在二进制数的最高位，称为符号位。0表示`+`，1表示`-`。
- 机器数   (机器内部使用)
  - 将符号和数值一起编码表示的二进制数称为机器数（机器码）
- 四种机器数
  - 原码 Signed magnitude     反码 One’s complement
  - 补码 Two’s complement    移码 Biased notation

#### 原码表示法

- 增加符号位  Add a sign bit  
  - 最高位为符号位，0：正，1：负，数值位不变
- 设机器字长为n+1位，定点小数x的原码形式为x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> (x<sub>0</sub>为符号位) ，则定点小数的原码定义如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922154424.png)

- 设机器字长为n+1位，定点整数x的原码形式为x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> (x<sub>0</sub>为符号位) ，定点整数的原码定义如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922154446.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922154730.png)

- 原码特点
  - 直观易懂
    - 第一位为符号位
    - 其他为数值位
  - 正零负零两个零：[+0]<sub>原</sub>=00…0，[-0]<sub>原</sub>=10…0
  - 加、减运算方式不统一
    - 符号相异加法不能直接运算
    - 特别当 a<b时，实现 a-b比较困难
  - 从50年代开始，整数都采用**补码**来表示
  - 但浮点数的尾数用原码定点小数表示

- 原码的表示范围
  - 设机器字长为n+1位，原码表示的定点小数，表示范围为|x|<1，原码表示的定点整数的表示范围|x|<2<sup>n</sup>
  - 设机器字长为n+1位，则定点整数x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>
    - 原码定点正整数的表示范围为 +00…0 ~ +11…1，即0 ~ 2<sup>n</sup>-1，
    - 原码定点负整数的表示范围为 -00…0 ~ -11…1，即-0 ~ -(2<sup>n</sup>-1)，
    - 原码定点整数的表示范围：-11…1 ~ +11…1，即 -(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1
  - 设机器字长为n+1位，则定点小数x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>
    - 原码定点正小数的表示范围为+0.00…0 ~ +0.11…1，即0 ~ 1-2<sup>-n</sup>，
    - 原码定点负小数的表示范围为-0.00…0 ~ -0.11…1，即-0 ~ -(1-2<sup>-n</sup>)，
    - 原码定点小数的表示范围：-0.11…1 ~ +0.11…1，即 -(1-2<sup>-n</sup>) ~ 1-2<sup>-n</sup>
  - 对称区间

#### 反码

- 所谓反码，就是二进制的各位数码（除了符号位）**取反**（负数）
- 符号位表示方法与原码相同

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922160827.png)

- 反码表示法
  - 设机器字长为n+1位，定点小数x的反码形式为x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> （x<sub>0</sub>为符号位），则定点小数的反码定义如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922160930.png)

  - 设机器字长为n+1位，定点整数x的反码形式为x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> （x<sub>0</sub>为符号位），定点整数的反码定义如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922160943.png)

- 反码的特点
  - 由原码求反码的方法：
    - 正数的反码与其原码相同
    - 负数的反码：负数的原码符号位不动，其余位取相反码
  - 0的反码表示有两种：[+0]<sub>反</sub>=00…0，[-0]<sub>反</sub>=11…1
  - 求反用逻辑门容易实现
  - 运算仍然很复杂
    - 相加时需要将符号位的进位位增加到LSB(最低有效位)上
  - 由反码求原码的方法：对反码再求反

- 反码的表示范围
  - 反码的表示范围和原码的表示范围相同
  - 设机器字长为n+1位，则定点整数x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> 
    - 反码定点整数的表示范围： -(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1
  - 设机器字长为n+1位，则定点小数x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> 
    - 反码定点小数的表示范围：-(1-2<sup>-n</sup>) ~ 1-2<sup>-n</sup>
  - 对称区间

#### 钟表对时

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922194647.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922194728.png)

#### 补码

**模**：符号位进位位的权值  
设模为M，则x的补码定义如下：  
- 真值为正数，补码等于原数据
- 真值为负值，补码是原负数加上模。

- 补码公式
  - 设机器字长为n+1位，定点小数x的补码形式为xx<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> （x<sub>0</sub>为符号位），则定点小数的补码定义如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922195440.png)

  - 设机器字长为n+1位，定点整数x的补码形式为x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> （x<sub>0</sub>为符号位），定点整数的补码定义如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922195457.png)

- 补码编码的简便方法——由原码求补码
  - 方法一：
    - 正数的补码同其原码
    - 负数的补码：原码的符号位保持不变，其余位按位变反，末位加1
    - 举例：[-10101010]<sub>补</sub>  =1 01010101+1 =1 01010110
  - 方法二：
    - 正数的补码同其原码
    -负数的补码：原码的符号位保持不变，从最右侧开始扫描找到第一个1，该1左侧所有数据位取反，其他数据位不变。
    -举例：[-0.010101]<sub>补</sub>=1.101011
  - 由补码求原码的方法：补码再求补

- 补码的特点
  - 零有唯一的表示方式
    - [＋0.0000]<sub>补</sub>= [-0.0000]<sub>补</sub>= 0.0000
  - 补码的符号位是数值的一部分，可直接参与运算
  - 假设机器字长n+1位，则补码比原码少了一个-0，多了一个-2<sup>n</sup>（整数）

- 补码的表示范围
  - 设机器字长n+1位，补码的定点整数的表示范围：-2<sup>n</sup> — 2<sup>n</sup>-1
  - 设机器字长为n+1位，则定点整数x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>  
    - 补码定点正整数的表示范围为+00…0 ~ +11…1，即0 ~ 2<sup>n</sup>-1，
    - 补码定点负整数的表示范围为-10…0 ~ -00…1，即 -2<sup>n</sup> ~ -1 ，
    - 补码定点整数的表示范围：-10…0 ~ +11…1，即 -2<sup>n</sup> ~ 2<sup>n</sup>-1
  - 设机器字长为n+1位，则定点小数x<sub>0</sub>...x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub> 
    - 补码定点正小数的表示范围为+0.00…0 ~ +0.11…1，即0 ~ 1-2<sup>-n</sup>，
    - 补码定点负小数的表示范围为-1.00…0 ~ -0.00…1，即-1 ~ -2<sup>-n</sup>，
    - 补码定点小数的表示范围：-1.00…0 ~ +0.11…1，即 -1 ~ 1-2<sup>-n</sup>
  - 非对称区间，左侧多了一个数

#### 变形补码

- 变形补码：双符号位的补码表示方法
- 作用：判断运算是否产生溢出。
假设机器字长n+1位，则定点整数和定点小数的变形补码分别如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922201558.png)

:::info 思考
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922202142.png)
:::

:::tip 不同机器数之间的转换
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922202432.png)
:::

#### 移码表示法

- 定义：假设机器字长n+1位，
	- [x]<sub>移</sub> = 2<sup>n</sup>+x     -2<sup>n</sup> ≤ x < 2<sup>n</sup>
- 保持数据原有大小顺序，便于进行比较操作。 
- 与补码的符号位相异，数据位相同

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922204450.png)

- 仅用于表示整数，通常表示浮点数的**阶码**

:::info 定点数机器码表示范围
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220922204154.png)
:::

### 定点数和浮点数

- 机器数（解决符号问题）

- 定点数 (小数点位置固定的数)
  - 定点整数
  - 定点小数
  - 仅能表示纯小数及纯整数

- 浮点数（解决小数点问题）

#### 几个概念

- **数值范围**：一种数据类型所能表示的最大值和最小值。
- **数据精度**：一个数的有效数字位数。
- 数值范围和数据精度均与使用多少位二进制位数以及编码方式有关
- 计算机用数字表示正负，**隐含规定小数点**。

- 定点整数

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923103203.png)

- 定点小数

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923103235.png)

#### 浮点数的表示

**浮点数**指小数点位置可以任意浮动的数据

表示：
- N=R<sup>E</sup>×M
  - N为浮点数
  - M为尾数
  - E为阶码(阶码定义见移码处)
  - R为“阶的基数（底）”，R为常数，一般为2,8,16，一台计算机中，所有数据的R都是相同的，不需要在每个数据中表现出来

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923103506.png)

#### 规格化浮点数

- 二进制数N=101.11，则其浮点表示可有多种表示方法：
  - N = 2<sup>11</sup> * 0.10111
  - N = 2<sup>100</sup> * 0.010111(此处100为二进制)
- 规格化浮点数——尾数的最高位为1的浮点数
  - 保障数据表示的唯一性，方便交换数据
  - 简化浮点运算算法
  - 提升表示精度，尾数去掉了左侧多余的零
- 原码的规格化后：正数：0.1X…X  的形式	负数：1.1X…X 的形式
- 补码的规格化后：正数：0.1X…X  的形式	负数：1.0X…X 的形式
- 机器零：当一个浮点数尾数为0时，不论其阶码为何值；或阶码等于或小于它所能表示的最小数时，不管其尾数为何值，机器都把该浮点数当作零看待，并称之为“机器零”。

:::info 例题
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923104155.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923104224.png)
:::

#### 浮点数标准IEEE754

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923104336.png)

- 构成：阶码E，尾数M，符号位S
- 阶码和尾码的位数的分配实际是表示范围和精度的折衷
- N = (−1)<sup>S</sup>  *  M  * 2<sup>E</sup> 
- 阶码**移码**表示，阶码的真值都被加上一个常数（偏移量），偏移量`127`或者`1023`，尾数**原码**表示，**符号位放在第一位**
  - 方便定点数逻辑比较浮点数大小

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923104626.png)

:::info 例题
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923104812.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923104825.png)
:::

### 非数值数据的表示

#### 字符表示法

- ASCII
  - 使用7bit表示128个字符
    - From 000 0000 to 111 1111  2<sup>7</sup>=128
  - 注意：ASCII中的数字字符和数字本身不相等
  - 几乎所有计算机均支持该代码集

#### 汉字表示法

- 汉字的**输入码**——直接从输入设备输入的各种汉字输入方法的编码
- 汉字**机内码**——是汉字存储在计算机内的编码
- 汉字**字模码**——是以点阵方式表示汉字，将汉字分解为若干个“点”组成的点阵字形。

1. 汉字机内码
  - GB2312国家标准
    - 1981年, 16位表示,又称为**国标码或国际交换码**
    - 一级常用汉字3755个，按汉语拼音排列
    - 二级常用汉字3008个，按偏旁部首排列
    - 非汉字字符682个
  - 94*94矩阵  **区位码**（行---区，列---位）
    - 一级汉字 16-55区 二级汉字 56-87区
    - 三级汉字 1-9区   用户自定义10-15区
  - **汉字机内码**：将国标码或区位码两个字节的最高位变为1
    - 国标码的两个字节分别加80H即可得到对应的机内码
    - 区位码的两个字节分别加A0H得到对应的机内码，即 区位码 + 0xA0A0
    - 与ASCII字符的区别，最高位=1
2. 字模码
  - 字模码是用点阵表示的汉字字型代码，是汉字的输出形式。 
    - 光栅字体，无法放大，屏幕描述
    - 矢量字体是如何表示的？ .TTF  True Type Font
  - 字模点阵信息量大，占用存储空间大
    - 以32*32为例，每个汉字要占用128个字节
  - 字模点阵只能用来构成汉字库，不能用于机内存储

### 数据的宽度和存储

#### 数据的宽度和单位

- 计算机中处理信息的单位：
  - **比特**（bit），简称“位”是计算机中存储、运算和传输信息的最小单位，用`b`表示
  - 在计算机内部，二进制信息的计量单位是“**字节**”（Byte），用`B`表示。1个字节等于8个比特。
  - 字（Word），有的由2个字节组成，有的由4，8甚至16个字节组成
- “字”和“字长”的区别
  - **字**表示被处理信息的单位，用来度量各种数据类型的宽度
  - **字长**表示进行数据运算、存储和传送的部件的宽度，反映计算机处理信息的能力
  - “字”和“字长”的长度可以一样，也可以不一样
  - 例如：80386以后的机器字长至少都是32位，但是字的宽度都定义为16位

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923110030.png)

### 数据校验码

- 解决编码在*时间、空间*上*传输可靠性*问题
- 编码中引入一定*冗余*，增加*最小码距*，使编码符合某种*规则*，当编码出现一个或多个错误时变成*非法代码*（不符合规则）
- **码距**：任意两个合法编码间不同的二进制位数
- 数据校验方法的思想——**冗余校验**
- 除了原数据信息外，还增加若干位编码，这些新增的代码被称为校验位
- 有效的数据位和校验位组合成**数据校验码**

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220923110608.png)

- 三种校验码
  - **奇偶校验码**：只能检查出奇数位错，不能纠错
  - **海明校验码**：既能检错，也能纠错
  - **循环冗余校验码**：既能检错，也能纠错

#### 奇偶校验码

- 增加一位校验位使码字中1的个数凑成奇数为**奇校验**
- 增加一位校验位使码字中1的个数凑成偶数为**偶校验**

|数据|偶校验码|奇校验码|
|:--:|:--:|:--:|
|11000001|11000001**1**|11000001**0**|
|11000010|11000010**1**|11000010**0**|
|11000011|11000011**0**|11000011**1**|
|11000100|11000100**1**|11000100**0**|
|11000101|11000101**0**|11000101**1**|

- 校验性能和适用情况
  - **识别奇数位错**，不能纠错，不保证正确，实现简单，编码效率高
 应用于存储器读写检查或ASCII码传送检查

#### 循环冗余校验码CRC(cyclic redundancy check)

- 模2运算
  - 模2加减
    - 按位加，可用**异或**逻辑实现，模2加与模2减的结果相同。
    - 即：0±0=0，0 ±1 = 1 ±0=1，1 ±1=0。
  - 模2乘——按模2加求部分积之和
  - 模2除——按模2减求部分余数
    - 上商的原则：当部分余数的首位为1时，商取1；当部分余数的首位为0时，商取0，当部分的余数的位数小于除数的位数时，该余数即为最后余数。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928081533.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928082234.png)

- CRC码的编码方法
  - 设原始信息码n位，加校验位k位
    1. 将原始信息码左移k位当被除数（后面加K个0）
    2. 选定一个k+1位的生成多项式做除数
    3. 模2除所得**余数**作为**校验位**
    4. 原始信息码后加校验位即为CRC码
  - 验证：
    - 将原始信息码左移k位加上余数校验位后新信息码一定是生成多项式的整数倍
  - CRC码运用于通信传输领域，磁存储领域

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928082747.png)

- 检错和纠错
  - 合法的CRC码在接收端能够被同一个生成多项式整除，即余数为0
  - 如果CRC码中只有一位出错，则余数码与出错位有对应关系。
  - 假设得到的CRC码C<sub>7</sub>C<sub>6</sub>C<sub>5</sub>C<sub>4</sub>C<sub>3</sub>C<sub>2</sub>C<sub>1</sub>=1100011，将这个数据与1011 进行模2除法，得到的余数为001，则说明C<sub>1</sub>出错，将C<sub>1</sub>取反即可。 

- 关于生成多项式
  - 任何一位发生错误都应使余数不为0
  - 不同位发生错误应当使余数不同
  - 对余数继续做模2除，应使余数循环

## 定点数加减运算

### 补码加减运算规则

- 参加运算的两个操作数均用补码表示。
- 符号位作为数的一部分参加运算。
- 求差时将减数求补，用**求和**代替**求差**。
- 运算结果为**补码**，如果符号位为0，表明运算结果为正；如果符号位为1，表明运算结果为负。
- 符号位的进位为模值，应该丢掉。(即超过2<sup>n+1</sup>的进位要丢掉)

### 补码加减运算公式

- 补码加法：[X＋Y]<sub>补</sub> = [X]<sub>补</sub>＋ [Y]<sub>补</sub>
  - 和的补码 = 补码的和

- 补码减法：[X−Y]<sub>补</sub> = [X]<sub>补</sub>＋ [−Y]<sub>补</sub> = [X]<sub>补</sub>−[Y]<sub>补</sub>
  - 差的补码 = 补码的差
  - 减法变加法，关键是求机器负数[−Y]<sub>补</sub>

- 机器负数：[−Y]<sub>补</sub>= 对 [Y]<sub>补</sub>（包括符号位）逐位取反, 再在最低位加 1


### 符号（位）扩展

- 不同位数的整数补码相加减时
  - 位数少的补码符号位向左扩展
  - 一直扩展到符号位对齐
- 扩展方法：
  - 正数在扩展时都用0填充
  - 负数根据机器数的不同而不同
    - 原码表示负数的扩展方法与正数相同，都填充0，但是符号位为1
    - 补码表示负数的扩展方法：原符号位移到新形式的符号位，整数都填充1，小数都填充0
    - 反码表示负数的扩展方法：原符号位移到新形式的符号位，其余附加位都填充1


### 溢出判断 

- 溢出：运算结果超出了机器数所能表示的范围
- 正溢：运算结果为`正`且大于所能表示的**最大正数**
- 负溢：运算结果为`负`且小于所能表示的**最小负数**
- 例：设定点整数字长8位，补码表示（最高位为符号位），表示范围为-128~127，运算结果超出此范围就发生溢出。  
  - 两个**异号数相加**或两个**同号数相减**，结果不会溢出
  - 两个**同号数相加**或两个**异号数相减**，有可能发生溢出

溢出判断方法:
#### 1. 根据符号位判断

- 当两个同号数相加，若所得结果符号与两数符号不同，则表示溢出。即正正得负，负负得正

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928195024.png)

#### 2. 根据符号位产生的进位和最高有效数位产生的进位判断

- 判断方法：
  - 两正数相加，最高有效位有进位，符号位无进位
  - 两负数相加，最高有效位无进位，符号位有进位

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928195558.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928195645.png)

#### 3. 根据变形补码来判断

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928200050.png)

## 定点数乘除运算

### 原码一位乘法运算

- 运算方法：
  - 符号单独运算：直接异或
  - 绝对值相乘

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928201359.png)

例子：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928201606.png)

- 寄存器设置
  - `寄存器A`——**存放部分积的累加和**，初始值为0；运算结束后，寄存器A中存放**乘积的高位部分**。
  - `寄存器B`——**存放被乘数X**（绝对值参加运算，符号单独处理）。
  - `寄存器C`——**存放乘数Y**（初始值为乘数的绝对值，符号单独处理）。运算结束后，寄存器C中存放乘积的**低位部分**。

- 符号位处理
  - 由于在部分积进行累加时，数值位的最高有效位可能会产生进位，为了暂时存放这个进位，需要将A和B都设置为**双符号位**，用第一符号位表示部分积的符号，第二位暂时存放数值最高位的进位，在之后的右移操作中，第二符号位上的数将移回有效的数值位。

:::tip 
**例题**:

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928225724.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928225810.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928225848.png)

**原码一位乘法流程图**:

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928230043.png)

**实现原码一位乘法的逻辑线路图**:

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220928230119.png)
:::

### 原码一位除法运算

- 无符号整数一位除法

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929134300.png)

- 恢复余数法

- 不恢复余数法（加减交替法）：
  - 符号位不参加运算，对于定点小数要求|被除数|<|除数|。
  - 先用被除数减去除数，然后根据：
    - 当余数R>0时，商上“1”，余数左移一位，再减去除数；
    - 当余数R<0时，商上“0”，余数左移一位，再加上除数。
  - 要求n位商时（不含商符），需要做n次“左移、加/减”操作。若第n步余数为负时，则需要增加一步——加上除数恢复余数，使得最终的余数仍为绝对值形式。注意最后增加的一步不需要移位，最后的余数为r×2<sup>-n</sup>（与被除数同号）。

- 寄存器设置：
  - 寄存器A，双符号位，初始值为被除数的绝对值，之后存放各次操作所得的余数；
  - 寄存器B，双符号位，存放除数的绝对值；
  - 寄存器C，单符号位，存放商的绝对值，初始值为“0”。
  - 所得的商由寄存器的末位送入，且在产生新商的同时，原有商左移一位。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929140321.png)

## 浮点数运算

### 浮点数加减运算

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929141551.png)

#### 对阶

- 规则：阶码小的数向阶码大的数对齐，
  - 即将数值小的阶码调整到与数值大的阶码相同，并相应地调整其尾数(右移)
- 方法：用减法进行阶码比较
- 即求E=E<sub>x</sub>-E<sub>y</sub>
	- 若 E=0 ，不需对阶
	- 若 E≠0 ，将原来阶码小的尾数右移 |E| 位，阶码值加上|E| 

#### 结果规格化

- 设尾数用双符号位补码（即变形补码）表示
- 左规
  - 若运算结果是非规格化的数，例如尾数是11.1x…x或00.0x…x，需要将尾数左移，每左移一位，阶码减1，直到满足规格化条件为止(即尾数符与最高有效位不等)，应判断结果是否下溢
- 右规
  - 若运算结果发生溢出，例如尾数是10.x…x或01.x…x，这并不表明浮点结果会溢出，此时需调整阶码，将尾数右移一位，阶码加1，应判断结果是否上溢

#### 舍入操作

- 在对结果进行右规或对阶时，由于要右移掉尾数最低位，因此需要舍入。
- 0舍1入法——当移掉的最低位为1时，在尾数的末位加1，如果加1后使尾数溢出，则需要再进行一次右规

#### 判溢出

- 阶码溢出表示浮点数溢出。
- 在规格化和舍入时都可能发生溢出。
- 若阶码正常，加减运算正常结束；若阶码下溢，则置运算结果为机器零；若上溢，则置溢出标志

:::info 浮点运算举例
![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929162048.png)

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929162124.png)
:::

### 浮点数乘除运算

#### 浮点数乘法运算

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929142821.png)

- 阶码相加
  - 阶码相加可能产生溢出，要进行溢出判断，如溢出计算机要进行处理
- 尾数相乘
  - 尾数相乘可得积的尾数，可按定点乘法运算方法运算
- 结果规格化
  - 可按浮点加/减法运算规格化方式处理，舍入方式也相同

#### 浮点数除法运算

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929142953.png)

- 尾数调整
  - 如被除数尾数大于除数尾数 (绝对值)，则将被除数尾数右移一位，阶码+1
- 阶码求差
  - 商的阶码等于被除数的阶码减去除数的阶码
- 尾数相除
  - 以被除数的尾数除以除数的尾数以获得商的尾数，尾数相除与定点除法运算相同

## 运算器的组成与工作原理

### 运算器的功能和组成

#### 运算器的功能

- **算术运算和逻辑运算**
  - 运算电路
- **暂存运算数据及中间结果**
  - 通用寄存器
- **选取数据参与运算**
  - 多路选择、锁存器
- **反映运算处理的状态**
  - 程序状态字

#### 运算器的组成

- **多功能算术/逻辑运算单元ALU**(核心部件)
  - 实现算术和逻辑运算，ALU受`控制器`发出的微操作信号控制，而控制器是按指令的要求来发微操作信号。它**并行处理的数据长度**与**计算机的字长**有关。
- 通用寄存器组GRS
  - 存放参加运算的操作数或保存运算的中间结果，它的工作速度大大高于主存，与CPU匹配，大量的通用寄存器用于存放运算的中间结果，可减少访内次数，达到提高机器运算速度的目的
- 多路选择器
  - 选择一路数据进行输出
- 锁存器
  - 用于锁存要操作的数据，来自GRS(通用寄存器组)，PC的偏移量等功能部件的数据。
- 程序状态字寄存器PSR
  - 条件转移指令常常使用的指令码记录了ALU执行操作后的状态。
- 移位器
  - 移位器主要用于实现移位指令的功能。

#### ALU

- 主要完成对二进制代码的定点算术运算和逻辑运算
- **算术运算主要包括定点加、减运算**
- 逻辑运算主要有逻辑与、逻辑或、逻辑异或和逻辑非操作
- ALU还要完成数值比较、变更数值符号、计算操作数的地址等操作
- ALU是一种功能较强的组合逻辑电路，有时称为多功能函数发生器
- **ALU的核心是加法器**
- 以加法器为核心，通过输入选择逻辑扩展为具有多种算术和逻辑运算功能的ALU

#### 二进制加法运算

- 各位逐位相加，进位从右至左传递
- 首先要考虑一位加法，然后考虑进位链

#### 一位加法逻辑电路实现

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929155447.png)

### 全加器

- 全加器有3个输入量：
  - A操作数的第i位A<sub>i</sub> , 
  - B操作数的第i位B<sub>i</sub>
  - 低位送来的进位C<sub>i</sub>
- 2个输出量：
  - 全加和 S<sub>i</sub>
  - 向高位的进位C<sub>i+1</sub>
- 考虑了全部3个输入的加法单元，称为**全加器**。只考虑2个输入的加法单元，称为**半加器**。
- 半加求和可用**异或门**实现，因此将异或门称为半加器。
- 全加求和可分解为*两次半加*，全加器可用两个半加器构成

#### 基本逻辑组件

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929193459.png)

#### 带进位链的一位全加器

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929193705.png)

一位全加器逻辑电路图：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929193740.png)

n位加法器：

- n位加法器包含n个全加器；  
- 将n个一位全加器串联；  
- 低位进位输出连接到高位进位输入；

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929193859.png)

串行进位加法器：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929193930.png)

单符号位补码加法器电路(ripple carry adder)：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929193952.png)

#### 并行进位加法器

- 可以根据输入信号同时形成各位向高位的进位，而不必逐级传递进位信号，又被称为先行进位加法器、超前进位加法器。 
- 例如：4位二进制数相加时，产生的进位表达式如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929195256.png)

- 进位输出仅与最低位进位输入C<sub>0</sub>有关
- 位数越长，进位链电路复杂度越高
- 通常按照4位一组进行分组运算

分级、分组进位加法器——组内并行、组间串行的进位链:

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929195331.png)

分级、分组进位加法器——组内并行、组间并行的进位链:

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929195404.png)

与门异或门电路:

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929195427.png)

先行进位电路carry lookahead:

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929195500.png)

#### 补码减法

根据算术运算规则：[a-b]<sub>补</sub>=[a]<sub>补</sub>+[-b]<sub>补</sub>,[-b]的补码为：将[b]<sub>补</sub>的各位求反，并加1。  
由此，我们可以用加法器实现减法。

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929195658.png)

##### 将加法和减法组合

给定控制命令C=0，则ALU完成加法a+b；C=1，完成减法a-b。  
可以用选择器实现如下：

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929195747.png)

### 进位链的设计

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929143825.png)

### 运算器的内部总线结构

#### 单总线结构运算器

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929144038.png)

#### 双总线结构运算器

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929144129.png)

#### 三总线结构运算器

![](https://fusheng1221.oss-cn-beijing.aliyuncs.com/fusheng-001-img/20220929144146.png)

